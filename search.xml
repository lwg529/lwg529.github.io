<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode每日一练]]></title>
    <url>%2F2019%2F03%2F17%2Fleetcode-2019-03-17%2F</url>
    <content type="text"><![CDATA[题目，191. Number of 1 Bits123Input: 00000000000000000000000000001011Output: 3Explanation: The input binary string 00000000000000000000000000001011 has a total of three &apos;1&apos; bits. 解析 循环，每位和1与，不等于0，则count加1 1234567891011var hammingWeight = function(n) &#123; let count = 0; let mask = 1; for(let i = 0; i&lt; 32; i++) &#123; if((n&amp;mask) !== 0) &#123; count ++; &#125; mask &lt;&lt;= 1; // mask = mask*2;相当于1的位置左移 &#125; return count;&#125;; n&amp;(n-1)解法 1234假设n = 1 0 0 1 0 0 n-1= 1 0 0 0 1 1 n&amp;(n-1)=1 0 0 n和n-1只有最后的几位不一样，与运算之后，只剩下了前面相同的部分（100）,1的个数正好减少了1个 12345678var hammingWeight = function(n) &#123; let sum = 0; while (n != 0) &#123; sum++; n &amp;= (n - 1); &#125; return sum;&#125;;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode每日一练]]></title>
    <url>%2F2019%2F03%2F16%2Fleetcode-2019-03-16%2F</url>
    <content type="text"><![CDATA[题目，Path Sum III123456789101112131415root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8 10 / \ 5 -3 / \ \ 3 2 11 / \ \3 -2 1Return 3. The paths that sum to 8 are:1. 5 -&gt; 32. 5 -&gt; 2 -&gt; 13. -3 -&gt; 11 解析从整个树寻找和为sum = （左子树和为sum） + （右子树和为sum）+ （带根节点和为sum）12345678910111213141516let pathSum = function(root, sum) &#123; if (!root) return 0; return sumHelper(root, 0, sum) + pathSum(root.left, sum) + pathSum(root.right, sum);&#125;;let sumHelper = (root, pre, sum) =&gt; &#123; let count = 0; if (!root) return 0; //先求出之前的pre和当前节点的和 let total = pre + root.val; // total === sum,则寻找到了一组，值为1，不相等，则是0. 然后从左右子树找pre为total，和为sum的组合 if(total === sum) &#123; count = 1; &#125; return count + sumHelper(root.left, total, sum) + sumHelper(root.right, total, sum);&#125;;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode每日一练]]></title>
    <url>%2F2019%2F03%2F15%2Fleetcode-2019-03-15%2F</url>
    <content type="text"><![CDATA[题目，Remove Duplicates from Sorted ListInput: 1-&gt;1-&gt;2Output: 1-&gt;2 Input: 1-&gt;1-&gt;2-&gt;3-&gt;3Output: 1-&gt;2-&gt;3 解析删去有序链表中重复的元素 维护两个指针，一个指向当前不重复的最后一个元素，另一个进行依次扫描，遇到不重复的则更新第一个指针，继续扫描，否则就把前面指针指向当前元素的下一个（即把当前元素从链表中删除）。假设数组长度为N, 时间复杂度为O(N),空间复杂度为O(1)(2个指针占用的空间) 123456789101112131415var deleteDuplicates = function(head) &#123; if(!head) return head; if(head &amp;&amp; !head.next) return head; let current = head; let currentNext = head.next; while(currentNext !== null) &#123; if(currentNext.val === current.val) &#123; current.next = currentNext.next; &#125; else &#123; current = currentNext; &#125; currentNext = currentNext.next; &#125; return head;&#125;; 递归实现假设数组长度为N, 时间复杂度为O(N),空间复杂度为O(1)(2个指针占用的空间) 12345678910var deleteDuplicates = function(head) &#123; if(!head) return head; if(head &amp;&amp; !head.next) return head; let currentNode = head; deleteDuplicates(currentNode.next) if(currentNode.val === currentNode.next.val)&#123; currentNode.next = currentNode.next.next; &#125; return currentNode;&#125;;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode每日一练]]></title>
    <url>%2F2019%2F03%2F14%2Fleetcode-2019-03-14%2F</url>
    <content type="text"><![CDATA[题目，Middle of the Linked ListInput: [1,2,3,4,5]Output: Node 3 from this list (Serialization: [3,4,5])The returned node has value 3. (The judge’s serialization of this node is [3,4,5]).Note that we returned a ListNode object ans, such that:ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, and ans.next.next.next = NULL. Input: [1,2,3,4,5,6]Output: Node 4 from this list (Serialization: [4,5,6])Since the list has two middle nodes with values 3 and 4, we return the second one. 解析求中位数，如果是数组的长度是奇数，直接返回中间数，如果是偶数，返回中间2个数的第二个数。 最直接的想法就是，把所有的元素放入一个数组中，求中间的数字假设数组长度为N, 时间复杂度为O(N),空间复杂度为O(N)(数组占用的空间) 12345678var middleNode = function(head) &#123; // 把所有的元素装到一个数组中，然后求中位数 let arr = [head]; while(arr[arr.length -1].next !== null)&#123; arr.push(arr[arr.length -1].next) &#125; return arr[Math.trunc(arr.length/2)]&#125;; 设置2个指针，一快一满，快的是慢的移动速度的2倍，快的到达数组结尾时，慢的正好在中间假设数组长度为N, 时间复杂度为O(N),空间复杂度为O(1)(2个指针占用的空间) 12345678var middleNode = function(head) &#123; let slow = fast = head; while(fast &amp;&amp; fast.next !== null)&#123; slow = slow.next; fast = fast.next.next; &#125; return slow;&#125;;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019学习目标]]></title>
    <url>%2F2019%2F03%2F11%2F2019%E5%B9%B4%E7%9B%AE%E6%A0%87%2F</url>
    <content type="text"><![CDATA[前言工作一年多快2年了，中间还换了一次工作，2019，不忘初心，给自己一个目标，并努力的实现，越努力，越幸运。 目标 读6本书，红宝书， es6，react，不知道的js 写博客，1月2篇，共24篇 刷题，一天一道，365道题 其他书籍读2-4本]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[js数据类型判断和转换]]></title>
    <url>%2F2019%2F03%2F11%2Fjs%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD%E5%92%8C%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[前言无论笔试还是面试，总会问到数据类型和隐式转换。今天彻底整理一下这块的知识，希望对大家有帮助。 看到下面的题，是不是已经蒙了，读完这篇文章，就能顺利通关了1234567891011121314151617181920212223console.log([] == 0) //true console.log(![] == 0) //true console.log([] == ![]) //trueconsole.log([] == []) //falseconsole.log(&#123;&#125; == &#123;&#125;) //falseconsole.log(&#123;&#125; == !&#123;&#125;) //falseconsole.log([] == false) //trueconsole.log(&#123;&#125; == false) //falseif([]) &#123;console.log(3)&#125; //3 if([1] == [1])&#123;console.log(4)&#125; //没有输出console.log(&apos;2&apos; &gt; 10) //falseconsole.log(&apos;2&apos; &gt; &apos;10&apos;) //true 数据类型判断数据类型js数据类型一共有7种，undefined、 null、 boolean 、string、 number、 object、 Symbol 类型判断typeof12345678910111213typeof undefined //undefinedtypeof true //booleantypeof 42 //numbertypeof &apos;42&apos; //stringtypeof &#123; life: 42 &#125; //objectlet s = Symbol();typeof s //symbol//特殊情况typeof [1,2,3,4]// objecttypeof null //objecttypeof new Date() //objecttypeof function () &#123;&#125; //function 由此可以看出，typeof不能区分数组， null和对象 Object.prototype.toString.call1234567891011121314151617let getType=Object.prototype.toString;getType.call(undefined) //[object Undefined]console.log(getType.call(true)) //[object Boolean]console.log(getType.call(42)) //[object Number]console.log(getType.call(Symbol()))//[object Symbol]console.log(getType.call([1,2,3,4])) //[object Array]console.log(getType.call(null))//[object Null]console.log(getType.call(new Date())) //[object Date]console.log(getType.call(function () &#123;&#125; )) //[object Function] instanceofinstanceof运算符返回一个布尔值，表示对象是否为某个构造函数的实例。 instanceof运算符的左边是实例对象，右边是构造函数。它会检查右边构建函数的原型对象（prototype），是否在左边对象的原型链上。 12new Date instanceof Date //true[1,2,3] instanceof Array //true instanceof运算符只能用于对象，不适用原始类型的值。 constructor 属性prototype对象有一个constructor属性，默认指向prototype对象所在的构造函数。 12function P() &#123;&#125;P.prototype.constructor === P // true 12[1,2].constructor === Array //true&apos;123&apos;.constructor === String //true 面试常问怎么判断是不是数组instanceof、constructor、Object.prototype.toString.call、Array.isArray 1234[1,2] instanceof Array //true[1,2].constructor === Array //trueObject.prototype.toString.call([1,2]) === &apos;[object Array]&apos; //trueArray.isArray([1,2]) //true 如何判断一个对象是不是空对象转换成json字符串判断1JSON.stringify(&#123;&#125;) == &quot;&#123;&#125;&quot; for in 循环判断 1234567let isEmptyObject = function(obj) &#123; for (let key in obj) &#123; return false; &#125; return true;&#125;console.log(isEmptyObject(obj));//true 使用ES6的Object.keys() 1Object.keys(&#123;&#125;).length === 0 类似的数组转化成数组类数组和数组都可以读写，获取长度，遍历，但是类数组不能调用数组的方法，比如push等 1Array.prototype.slice.call(arguments) 或者Array.from(arguments) 字符串翻转‘abc’.split(‘’).reverse().join(‘’) 字符串和数组转换[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;].join(&#39;&#39;) //&#39;abc&#39;1&apos;abc&apos;.split(&apos;&apos;) //[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;] 类型转换显示类型转换转成数字，Number()、parseInt()、parseFloat()123456789101112131415161718192021222324252627282930// 数值：转换后还是原来的值Number(324) // 324// 字符串：如果可以被解析为数值，则转换为相应的数值Number(&apos;324&apos;) // 324// 字符串：如果不可以被解析为数值，返回 NaNNumber(&apos;324abc&apos;) // NaN// 空字符串转为0Number(&apos;&apos;) // 0// 布尔值：true 转成 1，false 转成 0Number(true) // 1Number(false) // 0// undefined：转成 NaNNumber(undefined) // NaN// null：转成0Number(null) // 0//对象转化Number(&#123;a: 1&#125;) // NaNNumber(&#123;&#125;) //NaN //数组Number([1, 2, 3]) // NaNNumber([5]) // 5Number([]) //0 Number方法参数是对象时转换规则 第一步，调用对象自身的valueOf方法。如果返回原始类型的值，则直接对该值使用Number函数，不再进行后续步骤。 第二步，如果valueOf方法返回的还是对象，则改为调用对象自身的toString方法。如果toString方法返回原始类型的值，则对该值使用Number函数，不再进行后续步骤。 第三步，如果toString方法返回的是对象，就报错。 转换规则示例： 123456789var obj = &#123;x: 1&#125;;Number(obj) // NaN// 等同于if (typeof obj.valueOf() === &apos;object&apos;) &#123; Number(obj.toString());&#125; else &#123; Number(obj.valueOf());&#125; 先使用valueOf返回了对象本身，再代用toString()返回了”[object Object]” 注意：任何涉及NaN的操作都返回NaN，NaN和任何值不相等 Boolean除了以下值的转换结果为false，其他的值全部为true。 false, &#39;&#39;, 0, NaN, null, undefined String函数可以将任意类型的值转化成字符串（1）原始类型值 123456789101112131415//数值：转为相应的字符串。String(123) // &quot;123&quot;//字符串：转换后还是原来的值。String(&apos;abc&apos;) // &quot;abc&quot;//布尔值：true转为字符串&quot;true&quot;，false转为字符串&quot;false&quot;。String(true) // &quot;true&quot;//undefined：转为字符串&quot;undefined&quot;。String(undefined) // &quot;undefined&quot;//null：转为字符串&quot;null&quot;。String(null) // &quot;null&quot; （2）对象 123456//String方法的参数如果是对象，返回一个类型字符串String(&#123;a: 1&#125;) // &quot;[object Object]&quot;//如果是数组，返回该数组的字符串形式。String([1, 2, 3]) // &quot;1,2,3&quot; String方法背后的转换规则，与Number方法基本相同，只是互换了valueOf方法和toString方法的执行顺序。 隐式类型转换自动转化为布尔值if条件，while, 自动转换为字符串主要发生在字符串加法，一个值为字符串，另一个非字符串，则后者直接转为字符串 123&apos;5&apos; + 1 // &apos;51&apos;&apos;5&apos; + true // &quot;5true&quot;&apos;5&apos; + &#123;&#125; // &quot;5[object Object]&quot; 自动转化为数值除了加法运算符（+）有可能把运算子转为字符串，其他运算符都会把运算子自动转成数值。 12345++/--(自增自减运算符) + - * / %(算术运算符) + &gt; &lt; &gt;= &lt;= == != === !=== (关系运算符) 12345678910111213&apos;5&apos; - &apos;2&apos; // 3&apos;5&apos; * &apos;2&apos; // 10true - 1 // 0false / &apos;5&apos; // 0//&apos;abc&apos;转为数值为NaN,NaN任何运算都是NaN&apos;abc&apos; - 1 // NaN//null进行Number运算转成0null + 1 // 1//undefined转为数值时为NaNundefined + 1 // NaN == 运算符（1）原始类型的数据会转换成数值类型再进行比较。 123456789101112131415161718192021222324252627281 == true // true// 等同于 1 === Number(true)0 == false // true// 等同于 0 === Number(false)2 == true // false// 等同于 2 === Number(true)&apos;true&apos; == true // false// 等同于 Number(&apos;true&apos;) === Number(true)// 等同于 NaN === 1&apos;&apos; == 0 // true// 等同于 Number(&apos;&apos;) === 0// 等同于 0 === 0&apos;&apos; == false // true// 等同于 Number(&apos;&apos;) === Number(false)// 等同于 0 === 0&apos;1&apos; == true // true// 等同于 Number(&apos;1&apos;) === Number(true)// 等同于 1 === 1&apos;\n 123 \t&apos; == 123 // true// 因为字符串转为数字时，省略前置和后置的空格 （2）对象与原始类型值比较 对象（这里指广义的对象，包括数组和函数）与原始类型的值比较时，对象转化成原始类型的值，再进行比较。 12345678[1] == 1 // true// 等同于 Number([1]) == 1[1] == &apos;1&apos; // true// 等同于 Number([1]) == Number(&apos;1&apos;)[1] == true // true// 等同于 Number([1]) == Number(true) 实战练习12345678910111213141516171819202122232425262728293031323334353637383940//true,空数组valueOf还是空数组，toString()转成得到空字符串，空字符串调用Number转成0console.log([] == 0) //true //true，非的运算级别高，空数组转为布尔值为true,所以![]得到的false，Number转换为0， 最后结果还是trueconsole.log(![] == 0) //true //true,前面是调用valueOf()后调用toString()转成false，后边是非转成falseconsole.log([] == ![]) //false，2个数组放在堆里面，栈中存储的是地址console.log([] == []) //引用类型存储在堆中，栈中的是地址，所以是falseconsole.log(&#123;&#125; == &#123;&#125;) //&#123;&#125;.valueOf().toString()得到的是[object, Object], !&#123;&#125;得到的是false，Number转换后不相等console.log(&#123;&#125; == !&#123;&#125;)//数组的valueOf().toString()后为空，所以是真console.log([] == false) //true//因为对象调用valueOf后为&#123;&#125;, toString后转为[object, Object]，Number后是NaN,//任何涉及NaN的操作都返回NaN，NaN和任何值不相等console.log(&#123;&#125; == false) //false//空数组的boolean值为trueif([]) &#123;console.log(3)&#125; //3 //2个数组的栈地址不同if([1] == [1])&#123;console.log(4)&#125; //没有输出//false,转成2&gt;10console.log(&apos;2&apos; &gt; 10) //都是字符串，按照字符串的unicode转换，&apos;2&apos;.charCodeAt() &gt; &apos;10&apos;.charCodeAt = 50 &gt; 49console.log(&apos;2&apos; &gt; &apos;10&apos;) //都是字符串，按照字符串的unicode转换console.log(&apos;abc&apos; &gt; &apos;b&apos;) //false 参考：http://javascript.ruanyifeng.com/grammar/conversion.html]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>数据类型</tag>
      </tags>
  </entry>
</search>
